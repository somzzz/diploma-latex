\chapter{Conclusions and Further Work}
\label{chapter:concl-further}

In this thesis I presented \project\ which is an educational tool for analysing the obscure process of dynamic linking and loading. \project\ has a user-friendly user interface and allows an interactive inspection of ELF executables. The project has created a positive user experience and has achieved its purpose of transmitting relevant knowledge. The current implementation status has met all the objectives proposed in \labelindexref{Chapter}{chapter:motiv_obj}. However feedback revealed that there are further issues to be addressed in order to make the tool accessible for users on various other platforms.

In the following sections I will briefly present the current implementation status along with some of the most important conclusions drawn from working on the \project\ project. I will also detail features that need attention, as well as compatibility aspects which need to be addressed in further work on the project.

\section{Current Status}
\label{sec:current-status}

The tool can be run on Linux systems with Intel x86 architecture, for inspecting ELF executables, with the exception of Ubuntu 16.04 as feedback has revealed. Its dependencies include \textit{python} with a minimum version of 2.7, the \textit{llvm} infrastructure with \textit{lldb} 3.6 and the \textit{Pyside} python module for Qt bindings.

At present, the \project\ tool offers support for inspecting the dynamic loading and dynamic linking process along with the lazy procedure linkage mechanism. This is done by using the two inspection modes of the tool.

\subsection{Inspection of Dynamic Linking and Lazy Binding}
\label{sub-sec:dynlink-curr-sts}

This mode allows the user to step through the program between key points for dynamic linking. It also highlights the lazy binding mechanism. At present it comprises of the following features:
\begin{itemize}
\item Opening a target ELF executable
\item Setting breakpoints on functions from shared libraries
\item Visualisation of the Global Offset Table (\textit{.got.plt}) and Trampoline Intermediate Stubs (\textit{.plt})
\item Visualisation of the program sections
\item Custom event-based stepping through the program
\end{itemize}

\subsection{Inspection of Dynamic Loading}
\label{sub-sec:dynload-curr-sts}

The Dynamic Loading Inspection mode presents the events on user calls to the dynamic loading procedure. There are \textit{dlopen}, \textit{dlsym} and \textit{dlclose} for C code. The mode has the following functionality:
\begin{itemize}
\item Opening a target ELF executable
\item Visualisation of the program modules (shared libraries) mapped in the program address space
\item Custom event-based stepping through the program (on \textit{dlopen}, \textit{dlsym} and \textit{dlclose} calls)
\end{itemize}

The above functionality can be achieved by using the fully functional \gui\ which can be seen in \labelindexref{Figure}{img:gui-link} and \labelindexref{Figure}{img:gui-load}.

\section{Further Work}
\label{sec:further-work}

Further development of \project\ should focus the main issues addressed by user feedback which are described in \labelindexref{Chapter}{chapter:eval-test}. After that, work on self-standing features should be considered. Below I will detail the main areas of future development.

\subsection{Support for 64 bit Linux Systems}
\label{sub-sec:support-64-further}

Systems nowadays comprise of 64 bit software with increased virtual memory address space to make use of the increased hardware capabilities. For example, these include 64 bit CPUs with 64 bit registers and buses and bigger RAM memories. Commercial computers have transitioned to 64 bit systems both hardware and software wise in recent years and as user feedback revealed, most users have 64 bit software. 

\project\ should offer support for 64 bit Linux systems in order to be used by a wider range of users. The current implementation is valid for 32 bit machines only. One of the main setbacks is that \textit{lldb-3.6} does not properly extract the symbol stubs for the functions in the \textit{.plt} section for 64 bit systems. An approach to solving this issue is switching to a more recent \textit{lldb} version and making any necessary adaptations in the codebase. The \textit{lldb} version chosen must be able to inspect 64 bit ELF executables on any 64 bit system. 

Moreover, offering support for 64 bit systems also requires a thorough investigation of the executable format as generated by 64 bit compilers. It must be ensured that any difference in the ELF file is reflected by the manner in which the tool analyses it. 

\subsection{Migration to a Newer LLDB Version}
\label{sub-sec:lldb-version-further}

Feedback highlighted some issues with the way \textit{lldb-3.6} inspects 32 bit ELF executables on Ubuntu 16.04 specifically. Both command line debugger and python module do not find the symbol stubs for the functions in the \textit{.plt} section. The symbols are clearly present as \textit{gdb} can properly identify them and assembly comments inserted by the compiler can be visualised.

Similarly, one of the main issues of the current implementation with 64 bit systems is that \textit{lldb-3.6} does not identity the symbol stubs in the \textit{.plt} section. As was tested on 64 bit ELF executables, the \project\ \gui\ runs without errors and all widgets work as expected, displaying the correct information. The only setback is that the user cannot set any \textit{.plt} breakpoints as no functions are identified in the \textit{.plt}.

For the reasons stated above, further investigation is necessary into finding a \textit{lldb} version which is compatible with all 32 bit systems, primarily, as well as all 64 bit systems. In case this is not possible, it should be considered that an adequate \textit{lldb} version is installed depending on the user's system. Furthermore, compatibility issues between different \textit{lldb} versions should be documented and resolved in the \project\ project code.

\subsection{Support for Blocking Calls}
\label{sub-sec:blocking-further}

Feedback has pointed out that calls to blocking functions freeze the tool until the blocking call returns. Examples of such calls include server \textit{accept} functions, socket \textit{reads} and console input reads with functions such as \textit{scanf}. This issue is thoroughly described in \labelindexref{Section}{sub-sec:crontrol-flow-prob} and \labelindexref{Section}{sub-sec:tool-usage-feedback}. 

\project\ should handle blocking calls in a manner which allows the user to understand what is happening and what is required to unblock the target executable.

\subsection{Support for Parallel Execution}
\label{sub-sec:parallel-further}

At present, \project\ only supports inspection for single threaded executables. The tool extracts an instance of the first thread from the process of the executable. This thread is then used to obtain various information such as frame assembly code, program counter and so on. 

Support for multi-threaded applications must tackle issues such as the correct management of all threads within the \textit{lldb} wrapper module, as well as thread synchronization during the debugging session.

\subsection{ARM Support}
\label{sub-sec:arm-support-further}

Currently \project\ can analyse the dynamic linking and loading process for the x86 architecture. It would be useful to extend support to various other architectures such as ARM.

There are two main reasons why the current \project\ implementation does not offer ARM support. Firstly, ARM defines its own ISA \cite{arm-manual} which is fundamentally different from the x86 one. ARM is a \textit{RISC} architecture, whereas x86 is basically \textit{CISC}. Instructions differ from a conceptual point of view and not just by names. Secondly, ARM compilers generate a different executable format which cannot be analysed in the same way as its x86 counterpart. Being a low-level inspection tool, \project\ relies on a very strict instruction order for the assembly code. Any minor difference may result in unexpected behaviour.

Therefore, offering ARM support must be done in two stages. Firstly ARM executables must be analysed and differences from the x86 code should be noted. Secondly, the current implementation should be adapted to reflect the differences between the two architectures. A more general approach is preferred to simply duplicating code.

Moreover, as there are more ARM ISA versions ranging from \textit{ARMv1} to \textit{ARMv8}, further documentation is necessary on their differences. A decision should be made as to whether it is possible to analyse executables in a similar manner for all ARM versions or not. If it is not the case, one option is to gradually offer support for all, or some, individually.

\section{Conclusions}
\label{sec:conclusions}

\project\ is a dedicated educational tool for inspecting dynamic linking and dynamic loading. It is a light debugger with an user-friendly interface aimed at helping computer science students gain knowledge on the rather obscure dynamics of linking and loading.

The tool was evaluated by second and third year students primarily and the feedback received helped assess the quality of the software and improve user experience.

Firstly, the tool repository on Github was easily accessible and provided easy and clear installation instructions. The process was neither long, nor difficult and all the users who tested the application were able to get the tool with ease. To make the purpose of the tool clear at first glance, a short project description was also provided on the Github wiki.

Furthermore, the users were able to use the \gui\ without additional help. The intuitive design and placement of the widgets produced an effortless interaction between the user and the application. Moreover, any difficulty in understanding the purpose of the tool was eliminated by means of the \textit{Help} informative window and the console messages. Users who had no background on dynamic linking and loading found it most difficult to understand what the interface was showing them. The lack of theoretical knowledge was filled by the brief introduction to the dynamic linker and loader from the \textit{Help} window. Afterwards, users were able to properly follow and understand the process by means of the widgets on the \gui\ . Therefore, while the console messages provided descriptive information about each step, the various tables, code view windows and buttons gave the user a hands-on learning experience.

Most importantly, users assessed the tool positively regarding its educational purpose. They understood what dynamic linking and what dynamic loading were hands-on and gained detailed knowledge, rather than theoretical concepts alone. They stated that the mechanisms were straightforward and the process overall was easy to understand using \project\ . This underlines the fact that the key purpose of an educational tool was achieved and that a rather obscure mechanism was presented in a clear and easy manner.